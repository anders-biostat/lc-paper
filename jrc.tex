\documentclass[twocolumn,10pt]{article}

\usepackage[a4paper,hmargin=1.5cm,vmargin=2.5cm,]{geometry}
\setlength{\columnsep}{0.7cm}
\usepackage{palatino}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{minted}
\usemintedstyle{colorful}
\usepackage[font=small,labelfont=bf]{caption}
\urlstyle{same} % no tt font for URLs
\newcommand{\blockade}{\rule{3em}{0.7em}}  %% Marker for things to change before submission

\usepackage{natbib}
\bibliographystyle{genome_research}
\setcitestyle{aysep={}} 

\usepackage[dvipsnames]{xcolor}
\hypersetup{
    colorlinks,
    linkcolor={blue!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!50!black}
}

\begin{document}

\setcounter{secnumdepth}{0}


\twocolumn[{%
\centering
\textbf{\Large jrc: A novel way to exchange Commands Between R and 'JavaScript'}
\vspace{1.5ex}

Svetlana Ovchinnikova and Simon Anders\\
{\footnotesize Center for Molecular Biology of the University of Heidelberg, Germany}
\vspace{1.5ex}

24 January 2020
\vspace{6ex}
}]

\section{Abstract}

\section{Introduction}

\section{Discussion and Results}
\subsection{JavaScript-R bridge}

``jrc'' works as a simple bridge between R session and a web-page. It is built on top of the web socket technology (namely via the ``httpuv'' package). A ``jrc'' app starts a local server that maintains a web socket connection with each opened page, thus allowing to control each page from the R session in real time. The connection is two-sided, which means that also R calculations can be easily triggered by interacting with HTML elements.

User interface core of the package comprises of the four functions: sendCommand, callFunction, sendData and sendHTML. These are R functions, but each of them, except for the sendHTML, has a JavaScript counterpart, which is a method of the ``jrc'' object: jrs.sendCommand, jrc.callFunction and jrc.sendData. 
 
\begin{itemize}
\item sendCommand sends JavaScript code through the web socket connection to the web page and triggers its evaluation upon receiving. jrc.sendCommand in a similar manner sends R code from the web socket and evaluates it.

\item callFunction calls a JavaScript function on the web page using provided variables as arguments and storing the result, if any, in a specified variable. jrc.callFunction does the same with an R function. One can also specify a package, where to look for the function. The package must be already installed, but not necesserally loaded.

\item sendData converts a variable into JSON format, sends it to the web page and stores in a variable with a specified name. Since data are stored in the browser we do not recommed to send too big massives of data at once. It will make an app more robust if necessary data will be transfered on demand. jrc.sendData receives data also in JSON format, converts it to list, matrix or data.frame and stores in a variable with a specified name.

\item sendHTML adds custom HTML code to the web-page. The code is appended to the "body" element of the web-page. For obvious reasons, this functoin doesn't have a JavaScript counterpart.
\end{itemize}

These functions ensure that at any moment one gets a very straight forward and low-level control over the web-page or the R session, which makes ``jrc'' a simple, yet effective building stone for interactive JavaScript-based packages that can be both used locally or deployed on a server. All the aforementioned functions have a capability of to stall execution of an R script for a given time or untill a response from the web-page is received, which allows them to be used in complex scripts.

\subsection{App and Session}

While a set of JavaScript-R communication functions, ennumerated in the previous section, is the core of the user interface, the inner structucture of the ``jrc'' package is based on two object classes: App and Session. They are hidden (although still present), when one works with a jrc-app locally, by they play key role in maintaining multi-user connections, if app is deployed on a server.

Object of class App contain full information about a jrc app. It stores a server handle and information about all active connections. Methods of this object are used to monitor and force close connections, control data accessability and permits of the app within the current R session.

Object of class Session controls a connection to a certain web page. Instances of this class should not be created manually. They are initialized whenever a new web socket connection is established and stored in the corresponding App object. After the connection is closed, the object is removed from the memory. Session holds a connection to a web-page and processes all the incoming and outgoing messages. Session stores local variables, controls memory usage and handles all the commands evaluation. The functions from the previous section are all methods of a Session object. All Sessions receive certain default parameters when initialized, based on the App settings, but after that fucntion independently, each serving and maintaining its own connection. 

\subsubsection{Security}

The problem of security is only relevant if a jrc-app is made publicly available and is run from an R session on a server. Though ``jrc'' package provide similar capabilities for the both ends of the web-socket connection, security limits are in fact asymetric.

R session at any moment provides a full controly over each opened connection. Specifically, any JavaScript code can be evaluated on the web page, local variables can be inspected and manipulated with, information on the duration and activity of the connection can be obtained and the connection can be closed at any moment. However, jrc-app is incapable of doing anything more than running a JavaScript code in a browser. Thus, privacy of a person, who requests the page from the jrc-app server is protected by in-built browser limitations for JavaScript, which are quite strict.

On the other hand many of the commands incoming from the web-page to the R session must be authorized before execution. Specifically, any custom code always requires authorization. As for the functions and variable assignments, one can specify a list of functions that a web-page is allowed to call and variables that can be rewritten. Everything else will require manual authorization. There are also limitations for the local files that can be served by the server: by default these are only files that are stored in the root directory of the server. One can also add other directories to the list of allowed directories. Attempt file outside of specified locations will cause the "Permition forbidden" response.

\subsection{Predefining behaviour}


\begin{small} 
\balance
%\bibliography{lc}
\end{small}

\end{document}


