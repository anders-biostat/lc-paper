\documentclass[twocolumn,10pt]{article}

\usepackage[a4paper,hmargin=1.5cm,vmargin=2.5cm,]{geometry}
\setlength{\columnsep}{0.7cm}
\usepackage{palatino}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{balance}
\usepackage{dblfloatfix}  
\usemintedstyle{colorful}
\usepackage[font=small,labelfont=bf]{caption}
\urlstyle{same} % no tt font for URLs
\newcommand{\blockade}{\rule{3em}{0.7em}}  %% Marker for things to change before submission
\newcommand{\fixme}[1]{[ \blockade FIXME: #1]}

\usepackage{natbib}
\bibliographystyle{genome_research}
\setcitestyle{aysep={}} 

\usepackage[dvipsnames]{xcolor}
\hypersetup{
    colorlinks,
    linkcolor={blue!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!50!black}
}
\renewcommand{\dbltopfraction}{0.7}
\renewcommand{\textfraction}{0.2}

\begin{document}

\setcounter{secnumdepth}{0}


\twocolumn[{%
\centering
\textbf{\Large R/LinkedCharts: A novel approach for simple but powerful interactive data analysis}
\vspace{1.5ex}

Svetlana Ovchinnikova and Simon Anders\\
{\footnotesize Center for Molecular Biology of the University of Heidelberg, Germany}
\vspace{1.5ex}

24 January 2020
\vspace{6ex}
}]

\section{Abstract}
In any research project involving data-rich assays, exploratory data analysis is a crucial step. Typically,this involves jumping back and forth between visualizations that provide overview of the whole data and others that dive into details. In data quality assessment, for example, it might be very helpful to have one chart showing a summary statistic for all samples, and clicking on one of the data points would display details on this sample in a second plot. Setting up such interactively linked charts is usually too cumbersome and time-consuming to use them in \emph{ad hoc} analysis. We present R/LinkedCharts, a framework  that renders this tasks radically simple: Producing linked charts is as quickly done as is producing conventional static plots in R, requiring a data scientist to write only very few lines of simple R code to obtain complex and general visualization. We expect that the convenience of our new tool will enable data scientists and bioinformaticians to perform much deeper and more thorough EDA with much less effort. Furthermore, R/LinkedCharts apps, typically first written as quick-and-dirty hacks, can also later be polished to provide interactive data access in publication quality, thus contributing to open science.

\section{Introduction}

Effective data visualization has been crucial for scientific success since the first quantitative experiments. The continuously growing amount and complexity of available data over the last decades make this task more and more challenging. For a while, the only possible appproach was to develop ever more elaborate types of plots employing colour, shape, transparency, and other visual aspects to combine multiple layers of information \citep{bertin_2011, tufte_1983, wilkinson_1999}. Yet, there are certain limits to how much information one can learn from a static image \citep{hegarty_2011}. Excessive details and multiple overlapping layers make it harder to grasp the crux of a plot. Thus, a researcher has to decide what information to keep and what to dismiss to convey the message better \citep{odonoghue_2018}. This is, arguably, an essential step since data often contain much noise and information irrelevant to the point one tries to make. Yet, it may be useful to provide the reader with a way to estimate the relevance of the omitted pieces of data on his or her own to avoid biases \citep{bresciani_2009} and thus boost confidence in reported data patterns.

With the advance of modern computer technology, interactive visualization emerged to offer new ways of presenting information, starting already in the 1970s \citep{newman_1979, becker_1987}. In an interactive figure, there is no need to fix all the parameters or to exclude any data that do not contribute to the main idea. Instead, the user can experiment with the data and explore details quickly and intuitively, navigating to the plot's most exciting or suspicious parts. Numerous tools \citep{caldarola_2017} now provide means of inspecting many specific types of data with interactive tools. Examples from biology include metabolic maps \citep{noronha_2017}, genome assemblies \citep{wick_2015}, scRNA-Seq data \citep{hillje_2020}, QTL data \citep{broman_2015} and many more. While such solution are each tailored for one very specific type of data, there are also a number of general low-level frameworks to create interactive apps, such as D3 \citep{bostock_2011} and Vega-Lite \citep{satyanarayan_2015}, and more high-level but still general-purpose packages, such as Vega \citep{satyanarayan_2016}, Shiny \citep{shiny}, BPG \citep{p_2019}, and plotly \citep{sievert_2019, sievert_2020}. However, the gap between these general-purpose frameworks and special-purpose apps is still wide, as we discuss below.

The advantage of interactivity lies beyond just simplifying navigation through big or complex data. When it merely takes a click or two to add changes to a plot, this urges a researcher not to put aside ideas or concerns and thus go through the data more thoroughly. At the same time, readers can check conclusions and claims of a paper on the fly, without going through all the script and analysis, thus making the findings more credible. Therefore, we believe that further integration of interactive tools in a researchers' routine can significantly improve the quality of research \citep{shander_2016, yuk_2014}.

In practice, however, interactivity is still seriously underused during data analysis. Even though many authors now accompany their papers with an interactive resource to present their data and results (for example \citet{travaglini_2020, roider_2020, kalucka_2020}), these chiefly serve to present and communicate research that has already been completed. Commonly, it is only after most of the work on a project has been finished and the paper is being written up that researches spend a couple of days implementing a nice-looking interactive app to share their data and results with the scientific community \citep{batch_2017} to be added as supplement to their publication. 

\begin{figure*}[b]
	\includegraphics[width=\textwidth]{FigD/figD.png}
	\caption{An overview of genes differentially expressed in cancerous and normal tissues from \citet{conway_2015}. The MA plot (A) shows all the sequenced genes with their average expression on the X-axis and log-fold change on the Y-axis. Red indicates genes where the difference was reported as significant by the ``limma''  \citep{ritchie_2015}  package. The plot to the left (B) shows expression values (CPMs) for a selected gene (in this case, LAMB4) and all the patients. This figure is based on a LinkedCharts app, and its live version is provided in the supplement. When the user clicks on any point of the MA plot, the expression plot changes, showing the new selected gene. In this way, one can check immediately whether the genes labelled as significantly different are interesting for further study.}  
	\label{FigD}
\end{figure*}

Visualization frameworks must be simple, to encourage practitioners to use interactivity as soon as there is merely the smallest hint that it might be useful. If they are too complicated, one will prefer to do most of the analysis by more conventional static means, and wait for a special occasion when it is worthwhile to invest time and effort into an interactive app. Furthermore, a good framework should be similar in design to common static visualization frameworks to facilitate seemless switching from static to interactive data visualization.

However, too simple frameworks lack flexibility and work only for particular data structures and precisely matching data flow patterns. While much of routine work may involve only standardized steps and data types, interesting research tends to go beyond routine and should not be forced into a predefined mould.

Here, we present "LinkedCharts", a framework to perform interactive data exploration. 

With LinkedCharts, we aimed to find a balance between the simplicity of usage and possibility for flexible customisation. With only basic coding skills, users can create with just a few lines of code fully functional apps for \emph{ad hoc} analysis. These apps can then be improved by customising many plot settings such as colours, labels, axes, etc., and, by invetsing a bit more effort, turned into a "publication quality" app for deployment on a public server. Since the library is JavaScript-based, LinkedChart apps can be combined with various existing web solutions.

LinkedCharts is not fixed on any specific task. It is a toolbox, and its building blocks can be combined in any manner, the same way as one combines plots for a complex paper figure. All blocks share the same interface and very similar interactivity capabilities, which means that understanding one of them is enough to grasp the entire concept of LinkedCharts.

We hope that LinkedCharts can become a valuable asset for the scientific community that can be used both for everyday routine and for presenting one's research to a greater audience. LinkedCharts available as an R package (``rlc'', can be downloaded from CRAN) and as a JavaScript library. This paper's focus is on the R implementation of LinkedCharts, which we also refer to as R/LinkedCharts. 

\section{Results}

\subsection{Linking charts}

\begin{figure*}[t]
	\includegraphics[width=\textwidth]{FigB/figB.png}
	\caption{Typical syntax of an R/LinkedCharts plot with comparison to the ``ggplot2'' \citep{wickham_2016} package, one of the most commonly used plotting libraries. Lines of the code are arranged to put the same aspects of the charts next to each other. ``iris'' dataset, which is one of the R built-in datasets, was used for this example. Both pieces of code are fully functional, and their output is shown above the code.}
	\label{FigB}
\end{figure*}

As its name suggests, the central concept of LinkedCharts is linking and focusing \citep{buja_1991}: one can connect two or more plots thus that interactiving with one of them affects what is displayed in the others. We illustrate the concept  of lining charts using a simple example based on data from \citet{conway_2015}.

In that study, three samples were taken from each of 17 patients with oral cancer: of normal, cancerous, and dysplasic tissue. mRNA from all these samples was sequenced to obtain gene expression values. The goal was to find genes that differentially expressed between the tissue types -- a standard task in bioinformatics, readily addressed using available software tools \citep{ritchie_2015, love_2014}. Here, we have used the function \mintinline{R}{voom} \citep{law_2014} from the ``limma'' package to compare normal and cancerous tissues. It is common to visualise such a comparison with an MA plot \citep{dudoit_2002}, where each dot represents a gene, showing the gene's average expression on the X-axis and log fold change between the two groups on the Y-axis (Fig \ref{FigD}(A)). Red dots correspond to genes that are considered significantly different between the two conditions (adjusted p-value $<$ 0.1). 

About these genes, one may now wonder: How does the difference in expression look like for every single patient? Is it consistent across all the patients or only detected in some of them? Are there any artifacts or outliers that cause the p-value to be too small?

To investigate such questions, we can add another plot that shows expression values (as "counts per million", CPM) from each individual sample (Fig \ref{FigD}(B)). While this second plot can show expression for only one selected gene at a time, the \emph{linking} between the two charts  overcomes this limitation: A mouse click on a point in the MA plot causes the plot to the right to switch to displaying the expression values for the thus selected gene. Fig \ref{FigD} depicts a LinkedCharts app, which is provided in this paper's online supplement -- and we encourage the reader to pause for a moment and try it out. 

In the supplement, we also provide full code to generate the app and links to necessary data files to immediately get this app in one's R session and experiment with it. For this and all further examples, we provide two versions of the code: minimal with only essential parameters needed to make the app functional, and more extended with custom colours, labels, etc. In the paper, we only focus on the minimal code.

\begin{figure*}[b]
	\includegraphics[width=\textwidth]{FigA/figA.png}
	\caption{Gallery of all available plotting functions in the ``rlc'' package. A scatter plot (A); a bee swarm plot (based on d3-beeswarm plugin \citep{lebeau_2017}) (B); a collection of various lines (C); a histogram and a density plot (density was multiplied by a factor of 500 to be visible on the same plot as the histogram) (D); a heatmap (E); a bar chart (F); a collection of interactive elements to gather input from the user (G); functions to add custom HTML code and static plots to the page (H). All these examples with code to create them can be found in the supplement.}
	\label{FigA}
\end{figure*}

To illustrate typical usage of RLC and to explain the linking mechanism, we briefly discuss the code that generates the app shown in Fig \ref{FigD}. This is a minimal, but complete code for the app, suitable to illustrate the design principles of R/LinekdCharts. For now, we concentrate only on the highlighted lines.

\begin{minted}[xleftmargin=20pt, linenos, highlightlines={2,9-12,17}]{R}
openPage(layout = "table1x2")
gene <- 1

lc_scatter(dat(
   x = AveExpr,
   y = tissuetumour,
   colour = ifelse(adj.P.Val < 0.1, 
                   "red", "black"),
   on_click = function(k) {
      gene <<- k
      updateCharts("A2")
   }),
"A1", with = voomResult)

lc_scatter(dat(
   x = patient,
   y = normCounts[gene, ],
   colourValue = tissue, 
   logScaleY = 10),
"A2", with = sampleTable)
\end{minted}

In Line 2, we introduce a global variable, \mintinline{R}{gene}, which stores the index of the gene to be show in the right-hand plot. This index tells the chart which line of the \mintinline{R}{normCounts} matrix (where the normalized counts are stored) to use as \emph{y} values of the expression plot (Line 17). Almost every chart type in R/LinkedCharts has the \mintinline{R}{on_click} argument, which allows the user to define a function that is called whenever someone clicks on an element of the plot (point, line, cell of a heatmap, etc.) and is passed the index of the clicked element (\mintinline{R}{k}).  Here, our callback function simply changes the value of \mintinline{R}{gene} to the clicked point index (Line 10). Then, we tell R/LinkedCharts to update the second plot (Line 11; ``A2'' is its ID set in Line 20). Updating means that the package will reevaluate all arguments inside the \mintinline{R}{dat()} function and redraw the chart accordingly. In our case, a new value of \mintinline{R}{gene} will yield new \emph{y} values for the expression plot.

This simple logic is not limited to just two plots, but provides the basis to create many simple and complex apps. For example, the tutorial at \url{https://anders-biostat.github.io/linked-charts/rlc/tutorials/citeseq1.html} gives detailed instructions to generate an app for single-cell data exploration \fixme{Maybe include a picture of the app?}. The app consists of four charts, three of which are scatter plots and one is an information table to show genes that define a selected cell cluster.

Besides mouse clicks, LinkedCharts can react to other events, such as moving the mouse cursor over or out of an element, selecting or deselecting elements with the \emph{Shift} key pressed, clicking on any position of a plot or on a heatmap label. The complete list can be found on the man page of any function of the ``rlc'' package. Understanding how to define these callback functions (above is shown a very typical example) is all one needs to know to generate apps. 

\subsection{Basic syntax, chart types, and HTML5 integration}

We aimed to make R/LinkedCharts simple and familiar to any user with at least some basic knowledge of R. Every chart has a set of properties to define each of its specific aspects. In the previous example, we set the properties \mintinline{R}{x}, \mintinline{R}{y} and \mintinline{R}{color}, which received vectors of coordinates and colors to specify the scatter plots' data points. This principle will be familiar to most users from other plotting libraries. For example, Figure \ref{FigB} shows a comparison of the syntax in R/LinkedCharts (``rlc'' package) and ggplot (from the widely used ``ggplot2'' package by \citet{wickham_2016}) for a simple scatter plot. Lines are arranged to match the same aspects of the plots; above each code block, its output is shown. One can see that the input data structure is identical, and there is hardly any difference between the two.

R/LinkedCharts is not limited to scatter plots. There are 15 main functions in the ``rlc'' package, each generating a specific type of plot (such as scatter plot, heatmap, bar plot, etc.) or a navigation element (such as sliders or text fields). Figure \ref{FigA} shows them all. Each plot is defined by its properties: some of them are required (such as \mintinline{R}{x} and \mintinline{R}{y} for a scatter plot or \mintinline{R}{value} for a heatmap), others are optional (\mintinline{R}{palette}, \mintinline{R}{title}, \mintinline{R}{ticks} etc.). A full list of all the properties with live examples is available at \url{https://anders-biostat.github.io/linked-charts/rlc/tutorials/props.html} and also on the R man page of each plotting function.

LinkedCharts apps are displayed as HTML pages, using a standard Web browser. This means that the layout as well as decorations ( such as headlines) can easily be specified by producing a standard HTML5 page, in which the elements where the charts are to be places are marked as empty ``<div>'' elements. As knowledge of HTML5 is wide-spread, this allows practitioners to improve the appearance of LinkedCharts app without having to learn anything new. Furthermroe, it facilitates integrating LinkedCharts with other web-based apps. For example, one can easily link a LinkedChars app with a web-browser-based genome browser, such as IGV.js \cite{robinson_2020}, so that the user's interaction with the LinkedChart app controls what genomic region is displayed in IGV's genome track.

\subsection{Use cases}
\subsubsection{Back-tracking in analysis pipelines}

Most analysis of big data comprises multiple steps of data summerization, each reducing the total amount of data and thus losing information.

For example, in the oral-cancer example, we first have for each gene expression values from 28 samples, but the differential expression data analysis summarizes this to just 3 values: the gene's average expression over all samples, the fold change between tumour and healthy and the associated p value. The LinkedCharts app shown in Fig.\ \ref{FigD} allows to ``undo'' this summerization by inspecting the original values for each gene.

As an example of an analysis pipeline with multiple data-reduction steps, we use the drug-screening study of \citet{he_2018}. A collection of drugs was tested against various pancreatic cancer cell lines at several concentrations per drug. Figure \ref{FigC} illustrates a possible analysis pipeline: Panel A shows the viability read-out from the microtiter plates. For each combination of one cell line and one drug, the values for the different tested concentrations can be shown as a scatter plot, with each point depicting the viability value from one well (panel B). Here, we can fit dose-response curves, which can then be further summarized to a single number, such as the area under the curve, or, in the case of this study, a refined variant of that, called the drug sensitivity score (DSS) \citep{yadav_2014}. If two drugs show effect on the same subset of cell lines, they likely have similar mode of action. Hence, to assess similarity for each pair of drugs, we compare their activity over all cell lines, as shown by the scatter plots in panel C, where each point represents a cell line, with its x and y coordinate denoting the drug sensitivity scores of the that cell line for the two compared drugs. Again, we summarize each such plot into a single number, the correlation coefficient, and finally, we depict alll the correlation coefficients in a correlation-matrix heatmap (panel C).

Often, such an analysis pipeline is fully automated and no one ever looks at the intermediate plots of panel A to C. Inspecting such plots is, however, crucial to note problems with data quality of mistakes in the design or programming of the analysis pipeline.

LinkedChart allwos to ``walk'' such an analysis pipeline backward: In the Supplement, we show an app that depicts the plots of Figure \ref{FigC} in an interactive fashion, as follows. As each cell of the final heatmap (panel D of Fig.\ \ref{FigC}) summarizes on scatter plot comparing two drugs (panel C), we can click on any cell in the heatmap and then see the corresponding scatter plot. Each point in that scatter plot represents a pair of drug sensitivity scores, which are, themself, summaries of a dose response curves. Again, clicking on a point in the correlation scatter plot will display these two dose response curves. Finally, each value in a drug response curve stems from a well in a microtiter plate, and clicking on a point there hence highlights the well with a coloured border in a heatmap depicting the plate. \fixme{Can we add this last part?}

Thus, LinkedCharts allows to explore the ``parentage'' of any result value. If we find a specific drug-drug correlation value suspicious or surprising, or if we just wished to double-check it before drawing further conclusions from it, we can check its provenance in arbitrary detail. Similarly, we can perform random spot checks. 

Each layer in the backwards journey can inform about another type of problem: From the correlation scatter plots, we may find that the correlation coefficient was unduly influenced by a single out-lying cell line, from the dose response plot, we may find that specific does response curves fail to have the expected sigmoid shape, and from inspecting plate plots, we may trace back a surprising final result to, say, a normalization issue or an plate-edge effect.

\begin{figure*}
  \includegraphics[width=\textwidth]{FigC/figC.png}
  \caption{The main idea behind the LinkedCharts library is shown based on a drug screening experiment. The blue arrow shows the direction of a typical pipeline used in drug screening experiments. We start with reading intensity values from plates with different cell lines grown in the presence of studied drugs (A). These values are then normalised and urned into a fraction of the cells that remained metabolically active (RealTime-Glo$^{TM}$ assay, \citep{rtg}) or maintain membrane integrity (CellTox$^{TM}$ assay, \citep{ctx}). A sigmoid curve is fitted to the obtained viability or toxicity values at different drug's concentrations, and the area under the fitted curve yields a single score for each drug (B). Different drugs' scores are compared to each other across all the tested cell lines (D). A drug-drug correlation heatmap is then produced to identify clusters of similar drugs (C). Red arrows illustrate the visualisation direction. We start by showing the summary heatmap plot (C). Suppose the researcher is interested in a particular drug combination or a cluster of drugs. In that case, he or she can examine the corresponding drug scores simply by clicking on the heatmap cell (D). Similarly, one can examine the exact viability values for any given drug (B). And finally, if needed, it is possible to take one more step back and to look at raw read-outs to inspect them for the presence of any artefacts (A).}
  \label{FigC}
\end{figure*}

Once such an analysis pipeline has been developed, all the intermediate results are typically available in suitable data structures, which can be readily explored with LinkedCharts. The LinkedCharts web site provides code for the example just described.

\subsection{Quality assurance thresholds}

Typically, analysis pipelines include steps to exclude bad-quality data. Often, this is done by calculating quality metrics and setting thresholds. In the drug screen example, the goodness of fit of the dose response curves might be quantified by the residual sum of squares, and if this value exceeds a threshold, the drug sensitivity score might be discarded as unreliable. In the oral-cancer sample, the log fold change of some genes might be unduly influenced by a single outlying sample, and one might use a threshold on an outlier-detection score such as Cook's distance to flag such genes.

Typically, the thresholds on such quality metrics are chosen a priori, often simply taking over values from previous work or from tutorials, even though the characteristics of the assay might have changed. Doing otherwise seems to cause a chicken-and-egg problem: One cannot run the analysis without first somehow deciding on thresholds, and therefore, one cannot use analysis results to guide the choice of thresholds.

The approach of "walking the pipeline backwards" with LinkedCharts opens another approach: Typically, outliers tend to cause false positive results. Therefore, one can run the analysis first without excluding any outliers, then inspect the provenance of the statistically significant items found and will be so guided to specifically those places in the raw data where outliers can actually cause false positives. This provides the analyst with a better ``feel'' for the data and the analysis procedure and helps build an intuition that will allow to more critically judge whether tradtionally used standard values for quality-assurance thresholds are appropriate for the specific data set under analysis. 

\begin{figure*}[t]
	\includegraphics[width=\textwidth]{FigE/figE.png}
	\caption{ An example of an R/LinkedCharts app (C, D) that can be used during exploratory analysis and the code to generate it in comparison with the static plots (A, B) for the same purpose. The heatmaps (A, C) show Spearman correlation of gene expression for all samples from \citet{conway_2015}. Here, we can see two clear outliers in each heatmap's right and bottom and some more or less pronounced clusters of samples with similar gene expression levels. The scatter plots (B, D) show expression values for two samples plotted against each other. Browsing through several such plots can help the researcher get a feeling of the data and explore unexpected patterns like the outliers mentioned above. The code is split into two pieces, where the upper one is responsible for generating the plots and the lower part shows the code to update them. For static plots, one has to execute the same lines of code for any pair of samples he or she wants to compare, while for R/LinkedCharts the provided code should be added to the list of arguments for the heatmap. After that, switching between pairs of samples is done simply by clicking on the corresponding cell of the heatmap. The static heatmap (A) was generated with the ``pheatmap'' package  \citep{kolde_2019}; scatter plot (B) was made with a base R function. The live version of the app can be found in supplementary. For simplicity, gene expression for all the samples is subsetted to 8000 randomly selected genes.}
	\label{FigE}
\end{figure*}

\subsubsection{Exploratory analysis}

Analysing complex data sets from many different angles and asking many different questions on it is a crucial to all computational biology, not only to ensure that one does not overlook potential problems but also in order to not miss the cance of serendipious discoveries. The importance of such exploratory data analysis (EDA) has been argues since long, and it therefore forms a large part of computational biologists' everyday work. An important element is to pick examples and study them in detail, similarly to the aulity-assurance applications discussed in the previous section, but now with the aim of getting a ``feel'' for the data and looking for insights.

The standard approch in inspecting examples is to pick, e.g., a gene from a result list, produce a plot showing the provence of this result, the pick another gene, change the code for plotting to now show underlying data for this gene, etc. At that point, it is trivial to alter this code into a linked charts app, using the similarity between code for static and dynamic plots (Fig.\ \ref{FigE}).

Figure \ref{FigE} illustrates this with another example bassed on the oral cancer dataset. A bioinformatician had produced a correlation heatmap depicting correlations between all sample pairs (Fig.\ \ref{FigE}A), using, e.g., the pheatmap package \ref{}, and now wishes to inspect a specific correlation value (panel B) and writes to this end the short code shown in the figure. To inspect other sample pairs, she would simply change the sample indices in the code. This is routine practice for most bioinformaticians, but cumbersome. As the code example below the Figure shows, hoever, it is now virtually noe effort to transform the code into a LinkedChart app, by merely making a few simple substitutions (Fig. \ref{FigE}C,D).

\begin{figure*}[t]
   \includegraphics[width=\textwidth]{FigF/figF.png}
   \caption{An example of a stand-alone app with LinkedCharts. The app was used as a supplement for \cite{wang_2020}. Detailed information on the data, study goal and the source code for the app can be found in the related publication. The app is written in JavaScript and, thus, can be downloaded and opened in any modern browser without installation requirements. The app is based on the same principles as other examples throughout this paper. The main chart (upper row, centre) shows for every gene in the study its average expression and so-called $\Delta$-score, which indicates whether evolutionary changes in the translatome compensate for changes in the transcriptome or introduce new variance. The two plots below show expression values for the selected gene in all the tested samples. The user selects a gene by clicking on the corresponding point of the main plot or by entering the gene name (left upper corner). The density plot to the right shows the distribution of $\Delta$-scores, and its Y-axis is linked to the Y-axis of the main plot. In the upper right and bottom left corners, some additional information on the selected gene is displayed. Icons in the upper left corner allow switching between the studied tissues.}
   \label{FigF}
\end{figure*}

\subsection{Public apps and concurrent use}

Technically, an R/LinkedCharts app is provided by a web server running inside the R session and can hence be used from any web browser. Importantly, there is no need for that web browser to be running on the same computer as the R session. This allows a bioinformatician to easily share a LinkedChart application with colleagues. They only have to direct their operating system's firewall to open the TCP/IP port the app is listening at for incoming connections and tell their collegues their computer's IP address or DNA name and the port number, which these simply enter into their browser's address line.

As now multiple user might use the app simulteneously, we have to make sure that each user gets their own copy of any global variable, such as the variable \mintinline{R}{gene} in the initial code example. To do so, only a trivial change is required: one only has to list all such session variables at the beginning. In the initial code example, one would simply amend the first line to 
\mintinline{R}{openPage(layout = "table1x2", sessionVars = list( gene=1 ))}.


\subsection{LinkedCharts for Open Science}

Analyses in computational biology are often complex and involved, making them difficult to explain and even more so to verify. It is not uncommon that neither the peer reviewers nor the readers of a publication are effectively able to double-check a result unless they would be willing to redo the whole analysis themselves. The importance of making all raw data and code available to do that has been often stressed \citep{gentleman_2005}, but even, verifying a complex analysis is a demanding task.

Published interactive apps for data exploration are hence the enxt step towards open science. Traditionally, publications illustrate the chacteristics of typical data by showing ``typical examples'' -- but whether an example can be considered typical can be quite controversial. A LinkedCharts app in a paper's online supplement allows readers to chose their own examples rather than relying on the authors potentially ``cherry-picked'' ones. A second, less obvious, advantage is that interactivity can help clarify the details of a complex analysis.

To illustrate this, we describe a LinkedChart that we have provided as online supplement to the paper of \citet{Wang_2020}, a big-data study aiming at elcudating to which extent evolution of expression regulation acts on transcription and to which extent on translation. Using RNA-Seq and ribosomal footprinting data from three organs, taken from animals of six species, changes in transcript abundance and in translation of transcripts into proteins were quantified and compared. A core idea of the analysis was that the evolutionary changes to transcription and translation may either compensate for each other  (thus compensating deleterious changes in one layer by an opposite change in the other), or reinforce each other (in case of adaptive changes). To this extent, a score, denoted $\Delta$ was calculated, which is negative if the between-species difference is lower in the ribosome footprinting data than in the transcriptional data (thus indicating that transcriptional difference are at least partlt compensated on the translational layer) and positive if the variance at the ribosomal layer is higher (indicating reinforcement).

The definition of this $\Delta$ score is technical, and it is hard for the reader to form an intuition on its meaning. By ``playing around'' a bit with the app, available at \href{https://ex2plorer.kaessmannlab.org/} (static picture: Figure \ref{FigE}), this is quickly remedied:  The reader can click on any gene in the upper scatetr plot, inspecting examples of genes with positive, negative, or near-zero $\Delta$ score, and sees the data from the individual samples as well as the means per species. After a few clicks, the relationship between the transcriptional and the translational data on the one hand and the $\Delta$ score on the other hand will be clearer than several paragraphs of text achieve. The use of HTML design elements to position explanatory labels renders the app nearly self-explanatory. Here, it is not a simple picture, but an interactive one, that is worth the proverbial thousand word. 

The app, when considered as a supplement to the publication, hence offers multiple benefits: The app helps the reader in understanding the publication's core quantitative analysis, it explains the meaning of calculated scores, and . It allows the reader to verify that the examples discussed as typical in the paper are, in fact, typical, and not cherry-picked. Finally, it makes the data easily accessible; for example, readers can input their ``favorite'' gene to inspect its evolutionary analysis. All these aspects greatly contribute to making the publication's results truly open science -- the data is not only available somehow, but it is easily accessible.

\subsection{Javascript stand-alone apps}

Apps based on R/LinkedCharts (``rlc'' package) require a connection to a running R session. Typically, however, the server-side R session is only needed to data to the app and trigger updating of displayed charts, while all the visualisation and interactivity handling happens on the client side, by the part of LinkedChart written in JavaScript and running in the browser. In fact, this JavaScript component is the larger part of LinkedChart, the code in the R package ``rlc'' is merely a thin layer to handle communication between serevr and client.

The JavaScript part of LinkedChart can be used independent of R. The JavaScript library \emph{linked-chart.js} offers a user-friendly and well documented interface providing access to all the functionality described so far and all the chart types shwon in Figure \ref{}. Bioinformaticians familiar with JavaScript will find its use not much more difficult then use of the R package discussed so far. For every functionality, the LinkedChart documentation offers one page describing the R API and one describing the JavaScript API.

The advantage of working with the JavaScript library is that one can generate stand-alone apps, containing all code and data in a single HTML file. Such an HTML page can then be sent, as a single file, to a collaborator or used as a supplement file for a paper. Unlike a link to an app deployed somewhere on a server, this kind of interactive supplement will be available to any user with an installed web browser at any moment, without a need for the research team to maintain a running app on the server. The supplement to this paper is an example of such an app contained within an HTML page. Another example is the app for \citet{wang_2020} (Fig.\ \ref{figF}), discussed in the preceding section, which has also been implemented using the JavaScript rather and the R interface of LinkedCharts. 

As Javascript-based LinkedCharts do not requrie that a running R session is maintained on a server, they are especially suitable for inclusion on web pages served by existing web servers, as the HTML/JavaScript code for the app can simply be inserted into existing pages. Thus, a JS app may be used in a blog or even as a main figure of a scientific publication: Some journals have recently begun allowing for interactive plots to be included into online articles as main figures \citep{ingraham_2017}. So far, only the Plotly platform is typically supported, but as Plotly figrues are integrated by simply inserting HTML snippets, extension of such services to other HTML/JS-based interactive apps should be straight-forward.

If one wishes to pack all parts of the app into a single file, one obviously has to include the data. This can be done inside an HTML file using the JSON format. In our "Data import Tutorial", we explain this and also alternative ways of loading the data on demand, discussing also specific issues arising from web browser's security models.

Unfortunately, we can not provide users with an automated converter of R/LinkendCharts apps into their JavaScript counterparts. Unrestricted customisation is an essential part


\subsubsection{GUI apps}\label{gui_apps}

\begin{figure*}[t]
   \includegraphics[width=\textwidth]{FigG/figG.png}
   \caption{An example of an app that was used as a GUI to perform manual inspection and classification of LAMP testing for SARS-CoV-19 viral RNA \citep{herbst_2021}. The app was used in the lab of Prof. Dr. Michael Knop (ZMBH) during the SARS-CoV-2 surveillance study \citep{deckert_2021} and for voluntary testing for Covid-19 infection on campus (University of Heidelberg) offered since June 2020. To the right, the app shows a 96-well plate layout coloured either by content type (sample, empty, positive or negative control) or by the assigned result. To the left, it shows the results of three tests and one control for each sample. Accumulation of the product is indicated by the change of colour from red to yellow and is measured as a difference in absorbance on two wave lengths. This difference is plotted as a function of time. Besides exploration (highlighting the corresponding lines for each sample), the app allows to manually reassign status, store results locally as a \emph{.csv} file or send them to the server, where they can be requested by people who provided the sample. The app is provided as an R script. It was used in-house and not published. However, the code and some example data are available on GitHub at \url{https://github.com/anders-biostat/lamp_plate_analysis}}.
   \label{lc_FigG}
\end{figure*}

Broad possibilities for customisation make it possible to use R/LinkedCharts for tasks beyond its primary goal (which is, as it follows from the name, linking several charts together for intuitive exploration). Since callback functions of the ``rlc'' package are not restricted to any predefined list of tasks, one can access the full spectrum of R functionality. Interaction with a chart cannot only update the app state but also store information in variables or external files, read new input from a file or ask the user for input, trigger some complicated calculations, send requests and data to a server. With all this, an R/LinkedCharts app can work as a graphical user interface for a custom R task.

To this end, the ``rlc'' package (\mintinline{R}{lc_input} function, see Figure \ref{FigA}G) offers a collection of elements to gather user input. The function provides a LinkedCharts interface to HTML ``input'' tag to add buttons, checkboxes, radio buttons, scrolls and text fields to the app. As any chart of the ``rlc'' package, the \mintinline{R}{lc_input} can get an R callback that is triggered every time the user changes the state of an input element (clicks a button or enters new text).

A screenshot of such a GUI app is shown in Figure \ref{lc_FigG}. The app is a part of the project dedicated to applying loop-mediated isothermal amplification (LAMP, \citep{notomi_2000}) for detecting SARS-CoV-2 virus \citep{herbst_2021}.

At the beginning of 2020, the advance of Covid-19 infection quickly led to the overloading of available testing capacities and, in turn, hindered prompt detection of the disease spread, especially by asymptomatic carriers. To address the issue, LAMP tests were offered at the University of Heidelberg as a cheaper and simpler alternative to commonly performed qPCR tests. Like PCR, LAMP allows detecting the presence of a specified DNA sequence in a saliva or swab sample, amplifying it with the help of pre-made primers. However, LAMP reaction does not require cyclic temperature changes and, thus, is much easier to perform. The disadvantage of this technique is that it is more stochastic than qPCR, and one may want to test each sample multiple times to increase accuracy. 

Within a few months, a pipeline for RT-LAMP tests for the presence of SARS-CoV-2 viral RNA in saliva samples was successfully established. In this pipeline, after RNA extraction, each sample was split to fill four wells of a microplate. Three wells were used for testing and one for positive control (with other primers that will lead to product accumulation in any sample). LAMP tests can be run as colourimetric or as fluorescent assays. In both cases, the plates were heated up to $65^\circ$C and changes in absorbance or fluorescence were measured periodically for the next 50 minutes. If the sample is positive, in about 20 minutes, it should change colour from red to yellow (which can be measured as a difference of absorbance on 560 nm and 437 nm wavelengths) or become fluorescent. Due to the stochastic nature of the LAMP reaction, the resulting curve of absorbance or fluorescence changes over time should be observed manually for reliable conclusions. And that is where interactive visualisation is most helpful.

After establishing the pipeline, the lab offered its testing capacity for students and employees on the campus of the University of Heidelberg who wanted to get tested for Covid-19 infection and, later, for randomly chosen participants of the SARS-CoV-2 surveillance study \citep{deckert_2021}. For their convenience, a website was created where people could register their samples and query the result. The interactive app from Figure \ref{lc_FigG} was designed as a mediator between the output of the plate reader and the web platform.

It served multiple purposes. First of all, it was used by the involved lab members to inspect the results of colourimetric or fluorescence RT-LAMP scans. This is important due to the stochastic nature of the LAMP reaction. The results of all four performed tests are displayed in the app as four sets of curves showing changes in absorbance or fluorescence over time. To the right, there is a 96-well plate layout used for RNA extraction, coloured by either the well content (sample, control, empty) or by the assigned status (positive, negative, inconclusive, failed). If the user hovers the mouse over a particular well, all four corresponding curves are highlighted (as it is shown in Figure \ref{lc_FigG}). And vice versa: hovering the mouse over any of the curves, highlights all other curves and the well for the corresponding sample. Thus, it was easy for the lab members to conclude the final status of the sample.

Another purpose of the app is manual classification. An automated classification is also performed as an initial step. However, in some cases, manual adjustments are required to account for some randomness in the reaction. In addition, a ``failed'' status, which means that the sample can not be tested at all, can only be set manually. Any sample can be selected to assign a new status by pressing a corresponding button in the right bottom corner. One can also add a comment to any sample. The results can be then stored as a \emph{.csv} file.

Finally, the third purpose of the app was to push all the results to the server, where they could be queried by people who have provided the samples. A new dialogue window then appears for the user to log in to the server, and then a report is generated both as a log file and as an information table.

The app was used during the SARS-CoV-2 surveillance study \citep{deckert_2021} and for free voluntary testing for Covid-19 infection offered on the campus of the Heidelberg University during the pandemic of 2020/2021. This app is made for in-house usage and tailored for the pipeline of the specific lab and, thus, is not published. However, the source code is available on GitHub at \url{https://github.com/anders-biostat/lamp_plate_analysis}. It is provided in the form of an R script that reads in and processes the output of the microplate reader and then uses it to add interactive charts to the pre-made HTML page. The page contains an empty layout and functions to populate and ensure the functionality of non-LinkedCharts interactive elements. The R script is also responsible for storing any changes that are made in the app, saving them as an external file and pushing the results to the server. All this functionality is defined either as charts' callbacks or independent functions called by the ``jrc'' package.

Overall, the app is an example of not only a GUI made with the ``rlc'' package but also how one can utilise the power of JavaScript and R for interactivity in combination with R/LinkedCharts to ensure the behaviour that perfectly fits the needs of the given project.

\subsection{Further customization}

Since LinkedCharts is JavaScript-based, it can be combined with many existing web solutions without changing the source code of the package. One can customise the charts' appearance with CSS, add additional scripts, specify an HTML layout. R/LinkedCharts can add interactive charts to an existing HTML page supplied as \mintinline{R}{startPage} argument of the \mintinline{R}{openPage}. Additional images, files or scripts can be loaded from a directory specified by the \mintinline{R}{rootDirectory} argument. In addition, more experienced users can take a step back and utilise the ``jrc'' package (available on CRAN) to employ the full power of JavaScript for reacting to user's actions. The ``rlc'' package is based on ``jrc'' and inherits its main classes and, therefore, full ``jrc'' functionality is available for any R/LinkedCharts app by default. All this gives the user full control of what the app looks like and how it functions. Therefore a LinkedCharts app can be fitted to the specific needs of the particular project.

\section{Discussion}

Interactivity has already proved itself to be useful for data visualisation. Static plots can accommodate only a limited number of accents. Any change, no matter how small, requires one to make a new plot. And yet, it is crucial to look at the data from different angles and on different scales to find peculiar patterns and make sure that there are no hidden artefacts that can influence conclusions. Sometimes, even the visualised transition from one state to another is what helps to understand the data. Thus interactive visualisation is helpful during the research and for presenting data to the scientific community.

The field of interactive visualisation is an actively developing one with some already well known and established tools such as ``shiny'' \citep{shiny} or ``plotly''\citep{sievert_2020}. Yet, possible benefits of interactivity are far from being explored. We have described LinkedCharts as a library for spontaneous and highly customisable visualisation. A simple interface makes R/LinkedCharts suitable for generating minor on-the-fly apps for data exploration. It can be used by researchers with only basic experience in R or by bioinformaticians who are not willing to invest much time into an acquaintance with an unfamiliar visualisation library. The linking mechanism is ensured by user-defined callback functions, allowing R/LinkedCharts to do without requirements for fixed data structures. There are no restrictions on the linking scheme. Every chart can be linked to any other or multiple ones. Any kind of backwards or partial linking is also possible.

We believe easy exploratory analysis to be the main niche for R/Linked charts. As we have shown, it provides users with a possibility to generate visualisations with the same effort as one generally puts into routine data digging and exploration. However, interactive apps are much more engaging than the static plots commonly used in the early stages of any project. When checking an idea or concern takes just a click, the researcher is more likely to go through the data thoroughly and, with this, maybe, save time on the further steps of the analysis.

Once the need to present final or intermediate results to colleagues arises, the same essential apps that were previously used as ``quick and dirty'' solutions can be prettified and shared by deploying the app on a server. The required changes for a R/LinkedCharts app to work on the server are minimal, and therefore there is no need to start from scratch. One can utilise the same scripts as personal drafts for exploration and as a basis for result presentation.

LinkedCharts is a JavaScript-based library, and unlike in existing alternatives, we gave users complete freedom to employ the functionality of various web solutions. For example, R/LinkedCharts can be embedded into any predefined HTML layout. Therefore, someone with experience in web design may provide the researcher with a custom HTML page with allocated containers for the chart and any predefined functionality made available by hundreds of JavaScript packages explicitly developed to ensure user interaction with a web page. Moreover, the ``jrc'' package on top of which R/LinkedCharts is built allows running any JavaScript code from the R session and any R code from the web page, providing endless possibilities for custom functionality and design. Such an app can also load locally stored scripts, images, stylesheets, etc.

The JavaScript basis of R/LinkedCharts offers an interface of its own that is also very simple and similar to the ``rlc'' syntax. Therefore a user who is familiar with JavaScript or willing to learn its essentials gets a way to convert R app into a stand-alone one fully contained within an HTML page. Such an app doesn't require any side resources, can be shared by email between collaborators and opened in any browser. It does not need to have a constantly running R session and can be published on any hosting, including the most simple ones that do not allow to run other software in the background. An example of such stand-alone apps is the supplement to this paper. There, one can also find examples of conversion from R apps to JavaScript ones. More information can be found in our online tutorials.

The structure of the JS/LinkedCharts library and even principles of JavaScript as a language to manipulate DOM elements can allow an experienced user to customise not just the ecosystem in which LinkedCharts will be embedded but the charts themselves without a need to dive into the source code. One can go as far as defining custom types of charts (see \url{https://anders-biostat.github.io/linked-charts/js/tutorials/layers.html} for more details on that).

Overall, R/LinkedCharts serves two primary purposes to facilitate data exploration and presentation. It offers an easy way to utilise interactivity for everyday research tasks. And it also provides the user with a possibility to fully employ the power of JavaScript for presenting the data. The latter aspect addresses more experienced users and thus has no limits for possible customisation of a LinkedCharts app.


\subsection{Implementation}

The JavaScript foundation of R/LinkedCharts is built on top of the D3 \citep{bostock_2011} library. JS/LinkedCharts is by itself a fully functional tool for interactive data visualisation that can be used by those familiar with JavaScript to create stand-alone apps. The library is open-source and available on GitHub at \url{https://github.com/anders-biostat/linked-charts}. The minified version can be downloaded from \url{https://github.com/anders-biostat/linked-charts/raw/master/lib/linked-charts.min.js}, and its stylesheet is at \url{https://github.com/anders-biostat/linked-charts/raw/master/lib/linked-charts.css}.

The ``jrc'' package \citep{jrc_2020} package is used as a bridge between R and JavaScript. It allows one to run JavaScript code from an R session and vice versa. It also is managing client connections to the app and is responsible for all the functionality necessary to deploy R/LinkedCharts apps on a server. ``jrc'' in turn is based mainly on ``httpuv'' \citep{cheng_2020} package to run a local server and ensure a WebSocket connection \citep{fette_rfc_2011}. 

R/LinkedCharts (``rlc'' package) is an R \citep{R_2019} interface to the JavaScript version of LinkedCharts. In addition to providing access to JS/LinkedCharts functionality, it also ensures proper storing of charts and serving them to each connected client by extending ``App'' class of the ``jrc'' package. ``rlc'' is open source and is available on CRAN or GitHub \url{https://github.com/anders-biostat/rlc}.

%\balance
\begin{small} 
\bibliography{lc}
\end{small}

\end{document}


