\documentclass[twocolumn,10pt]{article}

\usepackage[a4paper,hmargin=1.5cm,vmargin=2.5cm,]{geometry}
\setlength{\columnsep}{0.7cm}
\usepackage{palatino}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{balance}
\usemintedstyle{colorful}
\usepackage[font=small,labelfont=bf]{caption}
\urlstyle{same} % no tt font for URLs
\newcommand{\blockade}{\rule{3em}{0.7em}}  %% Marker for things to change before submission

\usepackage{natbib}
\bibliographystyle{genome_research}
\setcitestyle{aysep={}} 

\usepackage[dvipsnames]{xcolor}
\hypersetup{
    colorlinks,
    linkcolor={blue!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!50!black}
}
\renewcommand{\dbltopfraction}{0.7}
\renewcommand{\textfraction}{0.2}

\begin{document}

\setcounter{secnumdepth}{0}


\twocolumn[{%
\centering
\textbf{\Large R/LinkedCharts: A novel approach for simple but powerful interactive data analysis}
\vspace{1.5ex}

Svetlana Ovchinnikova and Simon Anders\\
{\footnotesize Center for Molecular Biology of the University of Heidelberg, Germany}
\vspace{1.5ex}

24 January 2020
\vspace{6ex}
}]

\section{Abstract}
In exploratory data analysis, one usually jumps back and forth between visualizations that provide overview of the whole data and others that dive into details. In data quality assessment, for example, it might be very helpful to have one chart showing a summary statistic for all samples, and clicking on one of the data points would display details on this sample in a second plot. Setting up such interactively linked charts is usually cumbersome and time-consuming to use them in \emph{ad hoc} analysis. We present R/LinkedCharts, a framework  that renders this tasks radically simple: Producing linked charts is as quickly done as is producing conventional static plots in R, requiring a data scientist to write only very few lines of simple R code to obtain complex and general visualization. We expect that the convenience of our new tool will enable data scientists and bioinformaticians to perform much deeper and more thorough EDA with much less effort. Furthermore, R/LinkedCharts apps, typically first written as quick-and-dirty hacks, can also be polished to provide interactive data access in publication quality, thus contributing to open science.

\section{Introduction}

The problem of effective visualization has been there since the first reported experiment results \citep{friendly_2001}. The continuously growing amount and complexity of available data over the last decades made it a challenging issue \citep{fisher_2017}. For a while, the only possible way to tackle the problem was to develop more elaborate types of plots employing colour, shape, transparency, and other visual aspects to combine multiple layers of information \citep{keahey_2013, bertin_2011, heer_2009}. Yet, there are certain limits to how much information one can learn from a static image \citep{hegarty_2011}. Excessive details and multiple overlapping layers make it harder to grasp the crux of a plot. Thus, a researcher has to decide what information to keep and what to dismiss to convey the message better\citep{odonoghue_2018}. It is, doubtless, an essential step since data often contain a lot of noise and information irrelevant to the point one tries to make. Yet, it may be useful to provide the reader with a way to estimate the relevance of the omitted piece of data on his or her own to avoid biases \citep{bresciani_2009} and boost confidence in reported data patterns.

With the advance of modern technologies, interactive visualization emerged to offer new ways of presenting information \citep{newman_1979, becker_1987}.(It's been there since whatever...) In an interactive figure, there is no need to fix all the parameters or to exclude any data that do not contribute to the main idea. Instead, the user gets a chance to experiment with data and details quickly and intuitively, concentrating at once on the plot's most exciting or suspicious parts. Numerous tools \citep{caldarola_2017} now provide means of creating interactive visualizations not only for research \citep{noronha_2017, wick_2015, hillje_2020, broman_2015} but also for any area that involves data analysis and presentation of any kind \citep{zhao_2012, wu_2010}. Alongside apps for a specific task, one can also find low-level grammars \citep{bostock_2011, satyanarayan_2015}, and more high-level but still generally purposed packages \citep{satyanarayan_2016, shiny, p_2019, sievert_2019, sievert_2020}.

The advantage of interactivity lies beyond just simplifying navigation through big or complex data. When it takes just a click or two to add changes to a plot, it urges a researcher not to put aside ideas or concerns and thus go through the data more thoroughly. At the same time, readers can check conclusions and claims of a paper on the fly, without going through all the script and analysis, thus making the findings more credible. Therefore, we believe that further integration of interactive tools in a researchers' routine can significantly improve the quality of studies \citep{shander_2016, yuk_2014}.


Today many authors accompany their papers with an interactive resource to present their data and results \citep{travaglini_2020, roider_2020, kalucka_2020}. Though these visualizations are often useful and provide a comprehensive insight into the data, they generally serve presentation and communication purposes. Only after the most work on the project is finished, researches spend a couple of days deploying a fancy interactive app to share their data and results with the scientific community \citep{batch_2017}. We, however, believe, that interactivity should become a part of everyday routine to facilitate data exploration. To this end, the tool to produce interactive apps should be both simple and highly customizable.

\begin{figure*}[b]
	\includegraphics[width=\textwidth]{FigD/figD.png}
	\caption{Overview of genes differentially expressed in cancerous and normal tissues from \citet{conway_2015}. MA-plot (a) shows all the sequenced genes with their average expression on X-axis and log-fold change on Y-axis. Red indicates genes, where the difference was reported as significant by the ``limma''  \citep{ritchie_2015}  package. Plot to the left (b) shows expression values (CPMs) for a selected gene (in this case, LAMB4) and all the patients. This figure is based on a LinkedCharts app, and its live version is provided in the supplement. When the user clicks on a point of the MA-plot, the expression plot changes, showing the new selected gene. In such a way, one can check immediately, whether the genes, labeled as significantly different, are interesting for further study.}
	\label{FigD}
\end{figure*}

Simplicity should serve as an incentive to use interactivity whenever there is any smallest hint that it may be useful. If a tool is too complicated, one may prefer to do most of the analysis by more habitual static means, and wait for a special occasion when it is worthwhile to invest time and effort into an interactive app. It should also be similar in design to most common visualization means since tools with too specific interface tend to be used by people with more extensive programming skill. Even if a researcher with less expertise in coding has an eager-to-help colleague, he or she may be unwilling to ask for assistance in petty everyday tasks and wait for something big.

Still, an attempt to simplify a tool may end in hardcoding and presetting too many parameters. As a result, a simple-to-use tool can require a particular data structure and be fit only for precise data flow patterns. And any attempt of going beyond in-built limitations, if at all possible, can cost a considerable effort. It is not necessarily a disadvantage, since much of routine work in the lab involves typical for the area steps and data types. Yet, it may be useful if one does not try to force a research problem in the predefined mould but instead makes the visualization tool fit the given task. For that, a reasonable degree of flexibility is required.

With the LinkedCharts, we tried to find a balance between the two goals of a tool for interactive data exploration. It requires only basic coding skills to produce fully functional apps for \emph{ad hoc} analysis. With a little more effort, one can make a nicer looking app and customize most commonly used plot settings (such as colours, labels, axes, etc.). And finally, with the time and effort generally required for the same task with other packages, one can use LinkedCharts to make a presentable app deployed on a server. Since the library is JavaScript-based, it can be combined with various existing web solutions. One can also write custom scripts that will change even hardcoded aspects of the library without making changes to the source code, making LinkedCharts extremely flexible. 

LinkedCharts is not fixed on any specific task. It is a toolbox, and its blocks can be combined in any manner the same way as one combines plots for a complex paper figure. All blocks share the same interface and very similar interactivity capabilities, which means that understanding one of them is enough to grasp the entire concept of LinkedCharts.

With all these, we hope that LinkedCharts can become a useful asset for a scientific community that can be used both for everyday routine and for presenting one's research to a greater audience. LinkedCharts available as an R package (``rlc'', can be downloaded from CRAN) and as a JavaScript library. This paper's focus is on R implementation of LinkedCharts, which we also refer to as R/LinkedCharts. 

\section{Results}

\subsection{Linking charts}

The central concept behind LinkedCharts is, as follows from the name, linking and focusing \citep{buja_1991}. We connect two to or more plots so that manipulations with one of them affect the others. It is easier to understand how this concept works in LinkedCharts with a simple example based on data from \citet{conway_2015}.

In this study, three samples were taken from 17 patients with oral cancer: Of normal, cancerous, and dysplasia tissues. mRNA from all these samples was sequenced to obtain gene expression values. The first natural question to ask based on these data is about differential expression between various tissues. Several packages offer functionality to answer such questions  \citep{ritchie_2015, love_2014}. Here, we have applied function \mintinline{R}{voom} from the ``limma'' package to compare normal and cancerous tissues. It is common to visualize such a comparison with an MA-plot \citep{dudoit_2002} showing the average gene expression on the x-axis and log fold change between the two groups on the y-axis (Fig \ref{FigD} (a)). Red dots correspond to genes that are considered significantly different between the two conditions (adjusted p.value < 0.1). But how does the difference in expression look like for every single patient? Is it persistent across all the patients or only detected in some of them? Are there any artefacts or outliers that cause the p.value to be too small?

To find answers to these questions, we can add another plot that shows expression values (CPMs) for all the patients (Fig \ref{FigD}(b)). This plot can show expression for only one selected gene at a time, but LinkedCharts allows one to link it to the MA-plot. Now, any click on a point from the MA-plot makes the plot to the right show expression of the corresponding gene. Fig \ref{FigD} is based on the LinkedCharts app, which is provided in this paper's supplement. We encourage the reader to pause for a moment and check it to get a feeling of LinkedCharts. There, we also provide full code to generate the app and links to necessary data files to immediately get this app in one's R session and experiment with it. For this and all further examples, we provide two versions of code: minimal with only essential parameters needed to make app functional, and more extended with custom colours, labels, etc. In the paper, we only focus on the minimal code.

To further explore the linking mechanism, we can look at the code that generates the app from Fig \ref{FigD}. It is a minimal, but full code for the app. For now, we concentrate only on the highlighted lines.

\begin{minted}[highlightlines={2,9-12,17}]{R}
openPage(layout = "table1x2")
gene <- 1

lc_scatter(dat(
   x = AveExpr,
   y = tissuetumour,
   colour = ifelse(adj.P.Val < 0.1, 
                   "red", "black"),
   on_click = function(k) {
      gene <<- k
      updateCharts("A2")
   }),
"A1", with = voomResult)

lc_scatter(dat(
   x = patient,
   y = normCounts[gene, ],
   colourValue = tissue, 
   logScaleY = 10),
"A2", with = sampleTable)
\end{minted}

It works as follows. In the \mintinline{R}{gene} variable, we keep an index of the gene to show in the expression plot. This index is used to tell the chart, which line of the \mintinline{R}{normCounts} matrix (it is where normalized counts are stored) to use as y values of the plot: \mintinline{R}{y = normCounts[gene, ]}. Almost every chart of the R/LinkedCharts library has the \mintinline{R}{on_click} argument, which is a function, that will be called each time the user clicks on an element of the plot (point, line, cell of a heatmap, etc.). In this example, whenever it happens, we change the value of \mintinline{R}{gene} to the clicked point index. Then we tell R/LinkedCharts to update the second plot (``A2'' is its ID set in the last line of the example). Updating means that the package will reevaluate all arguments inside the \mintinline{R}{dat()} function and change the chart accordingly. In our case, a new value of \mintinline{R}{gene} will yield new y values for the expression plot.

This simple logic is not limited to just two plots and provides a base to create various simple and complex apps. For example, one of our tutorials (\url{https://anders-biostat.github.io/linked-charts/rlc/tutorials/citeseq1.html}) gives detailed instructions to generate an app for single-cell data exploration. The app consists of four charts, three of which are scatter plots and one is an information table to show genes that define a selected cell cluster.

Besides a click, LinkedCharts can react to other events, such as moving the mouse over or out of an element, selecting or deselecting elements with the \emph{Shift} key pressed, clicking on any position of a plot or on a heatmap label. The full list can be found on a man page for any function of the ``rlc'' package. Understanding how to define these functions (above is shown a very typical example) is everything one needs to generate apps that run locally. More profound knowledge is required only to deploy an R/LinkedCharts app on a server. 

\subsection{Basic syntax}

\begin{figure*}[t]
	\includegraphics[width=\textwidth]{FigB/figB.png}
	\caption{Typical syntax of an R/LinkedCharts plot and its comparison with the ``ggplot2'' \citep{wickham_2016} package as an example of one of the most commonly used plotting libraries. Lines of code are arranged to put the same aspects of the charts next to each other. ``iris'' dataset, which is one of the R built-in datasets, was used for this example. Both pieces of code are fully functional, and their output is shown above the code.}
	\label{FigB}
\end{figure*}

Overall, we tried to make R/LinkedCharts simple and recognizable by any user with a fundamental knowledge of R. Any chart has a set of properties to define each of its specific aspects. One can already notice this from the previous example, where vectors of values were used as x and y coordinates of points or their colours. The same principle works in most plotting libraries. For example, Figure \ref{FigB} shows a comparison of syntax in R/LinkedCharts (``rlc'' package) and ggplot (``ggplot2'' \citep{wickham_2016} package) for a simple scatter plot. Lines are arranged to match the same aspects of the plots; there is its output above each code block. One can see that the input data structure is identical, and there is hardly any difference between the two.

An important thing to notice here is the \mintinline{R}{dat()} function. One can set properties in the same manner both inside and outside of it, but only those that are inside the \mintinline{R}{dat()} function will be evaluated on each call of \mintinline{R}{updateCharts}. Everything outside this function will remain constant. There is a small example that can illustrate the effect of the \mintinline{R}{dat()} function.

\begin{minted}{R}
lc_scatter(
   dat(x = rnorm(30)),
   y = rnorm(30))
\end{minted}

Running this code will produce a scatter plot with 30 randomly located points. Now, every time one calls \mintinline{R}{updateCharts()} x coordinates of each dot will change to a new random value, but all the y coordinates will remain the same.


\begin{figure*}[t]
	\includegraphics[width=\textwidth]{FigA/figA.png}
	\caption{Gallery of all available plotting functions the in ``rlc'' package. A scatter plot (a); a bee swarm plot (based on d3-beeswarm plugin \citep{lebeau_2017}) (b); a collection of various lines (c); a histogram and a density plot (density was multiplied by a factor of 500 to be visible on the same plot as the histogram) (d); a heatmap (e); a bar chart (f); a collection of interactive elements to gather input from the user (g); functions to add custom HTML code and static plots to the page (h). All these examples with code to create them can be found in the supplement.}
	\label{FigA}
\end{figure*}

So far we have mentioned only scatter plots, but R/LinkedCharts is not limited to them. There are 15 main functions in the ``rlc'' package. Each generates a specific type of plot (such as scatter plot, heatmap, bar plot, etc.) or a navigation element (such as sliders or text fields). Figure \ref{FigA} shows them all together with some basic examples. Each plot, as it has been already mentioned, is defined by its properties: some of them are required (such as \mintinline{R}{x} and \mintinline{R}{y} for a scatter plot or \mintinline{R}{value} for a heatmap) many others are optional (\mintinline{R}{palette}, \mintinline{R}{title}, \mintinline{R}{ticks} etc.). A full list of all the properties with live examples is available at \url{https://anders-biostat.github.io/linked-charts/rlc/tutorials/props.html} and also on the R man page for each plotting function. Many of the properties accept minor variations in spelling (\mintinline{R}{colour/color} or \mintinline{R}{labels/label}).

\subsection{Use Cases}
\subsubsection{Quality check}

Generalising data is of great importance in any research project that concerns big data. It is troublesome to see patterns and make meaningful conclusions from raw readouts and measurements. Researches routinely count aligned mRNA reads, select only informative features, calculate various scores, etc. An appropriate generalisation is a key to uncovering biological patterns hidden in the data, but it also means loss of information.

Figure \ref{FigD} nicely illustrates the process. To see the overall difference between the tissue types defined by thousands of genes, we make an MA-plot. It immediately tells us that there is a big difference between the tissue types, noticeably more genes with higher expression levels in the cancerous tissue and that the difference in downregulated genes in tumour samples seems to be more pronounced. All that we get by representing the original 38 expression values (dysplasia samples not included) per sample for each gene with just three: average expression, logarithmised fold change in expression between normal and cancerous tissues, and the significance estimate of this difference. Such a generalisation allowed us to see the bigger picture but at the cost of individual expression values.

A similar approach is a part of almost any pipeline used in a biological study. Each step takes the output from the previous one and modifies it, usually by generalising it to produce more interpretable data. However, some information is inevitably put aside. And from the resulting picture alone, it is hard, if not impossible, to see whether the raw data had any problems that could influence further conclusions. Various quality checks are devised to detect any possible issues with the omitted data. They are often quite helpful in pointing the researcher's attention towards some spurious artefacts in the data. Yet, especially in studies involving big data, these checks are fully automated. The researcher only looks at some summarised reports and may also have a look at some random examples. If those look reasonable, the general assumption is that all the data not filtered out is valid. However, while there is only one way for everything to be correct, there are numerous ways for the data to be either wrong or not as one has expected. Therefore, it's essential to have a possibility to look back before making any conclusions from a figure that shows a condensed result.

This idea is the primary motivation behind the LinkedCharts library. Figure \ref{FigC} demonstrates it. If we have a workflow or a pipeline that performs certain transformations of the data, LinkedCharts offers an easy way to look back through each of the steps. Whenever a researcher encounters an interesting or suspicious pattern in the data, he or she can, with minimal effort, check whether it is a real biological finding or some technical artefact missed by quality checks. 

\begin{figure*}[h]
  \includegraphics[width=\textwidth]{FigC/figC.png}
  \caption{Main idea behind the LinkedCharts library is shown based on a drug screening experiment. The blue arrow shows the direction of a common pipeline used in drug screening experiments. We start with reading intensity values from plates with different cell lines grown in the presence of studied drugs in different concentrations (A). These values are then normalised and aggregated to yield a single score for each drug (B). Different drugs' scores are compared to each other across all the tested cell lines (C). A drug-drug correlation heatmap is then produced to identify clusters of similar drugs (D). Red arrows illustrate visualisation direction. We start by showing the summary heatmap plot (D). If the researcher is interested in a particular cell or a cluster of cells, he or she can examine the corresponding drug scores simply by clicking on the cell (C). Similarly, one can examine the exact viability values for any given drug (B). And finally, if needed, it's possible to take one more step back and to look at raw readouts to inspect them for the presence of any artefacts (A)}
  \label{FigC}
\end{figure*}

R/LinkedCharts is particularly useful in generating chains of ``linked'' plots, where each chart explains an element of the previous one. We presented one of the simplest examples in the ``Linking charts'' section as a basic R/LinkedCharts app. Figure \ref{FigC} shows another one with a longer chain, which is also available in the supplement. It is based on the data from \citet{he_2018}.

For demonstration purposes, we use only a subset of data to simulate a typical drug screening pipeline. In this subset, 50 drugs in five different concentrations were tested against 17 pancreatic cancer cell lines. The main heatmap shows drug-drug correlation values. By clicking on a cell of the heatmap, the user selects two drugs and can check individual drug scores for each of them against all the tested cell lines. The inhibition values were calculated based on drug activity in five tested concentrations. So the third plot shows all those activity levels for each concentration. Finally, one can also find raw readouts from the plates to check for plate-related effects, if any. In this manner, each chart represents one of the major steps of the pipeline that led from plate readouts to a correlation heatmap to identify clusters of drugs with similar behavioural patterns. One can find more details as well as code and links to download the data in the supplement. 

Such apps would allow a quick and easy spot check of uncovered data patterns and give the researcher a better understanding of inner connections between the data. For instance, to what extent noise can influence the signal or what scale of changes in the value of interest is typical to the data.

\subsubsection{Exploratory analysis}

While interactivity is already increasingly used to present results of finished studies to the research community, with R/LinkedCharts, we would like to point out its usefullness for everyday exploratory analysis. To this end, R/LinkedCharts is designed in a way that requires one to spend as much time desingning an app as it anyway would take to perform similar analysis. One may think of R/LinkedCharts as of a container, where the researcher can put his or her code to turn it into an interactive app. It will not perform any kind of elaborate analysis automatically, but it will also not ask for much more than the usual routine coding, one should do anyway. Basic, yet custom and functional apps do not require any special knowledge of ``rlc'' underlying structure or HTML layout. With this, we've attempted to encourage researches try out interactivity of as a more improvised an need-based approach.

Let us return to the example from Figure \ref{FigD}. There we showed a typical part of a differential expression study: an MA-plot (Figure \ref{FigD}A) and a plot with expression values for each sample to explore it (Figure \ref{FigD}B). We have already shown in Figure \ref{FigB} (section ``Basic Syntax'') that making a static plot in R/LinkedCharts is not much different in comparison to popular plotting libraries. It will take same effort and same data structuring an preprocessing to make these plots with, for example, the ``ggplot2'' library, as with the ``rlc''. Now, the plot in Figure \ref{FigD}B serves for spot checking. It allows one to dive into the details of expression patterns, but only for one gene at a time. Of course, one may decide to only rely on the general overview that is provided by the MA-Plot (Figure \ref{FigD}A), however, a better practice is to make sure that there are no unexpected expression artifacts in the genes of interest. To do that one would usually in some way (by filtering or using some special R tools) get a list of genes to check, and then make a plot like the one in Figure \ref{FigD}A for each of them.

In the most simple case it would take copying and pasting the code for the spot check plot and replacing \mintinline{R}{y = normCounts["MyGene", ]} with \mintinline{R}{y = normCounts["AnotherMyGene", ]} (see the code chunck in the section ``Linking Charts''. A little improvement to that would be to write \mintinline{R}{y = normCounts[myGene, ]} and keep updating the \mintinline{R}{myGene} variable: \mintinline{R}{myGene <- "MyGene"}, then \mintinline{R}{myGene <- "AnotherMyGene"}. After each update one should stil copy a piece of code that generates the plot into the console. Finally, the most effective way is to place this constantly coppied and pasted code into a function, let say, \mintinline{R}{makePlot} and to call it, when necessary: \mintinline{R}{makePlot("MyGene")}, then \mintinline{R}{makePlot("AnotherMyGene")}.

Now, we kindly ask the reader to make a little pause here, and return to the section ``Linking Charts'', where the code to produce the app from Figure \ref{FigD} is given. The \mintinline{R}{onClick} function does the same thing that is described in the previous paragraph. It stores the new gene into the variable \mintinline{R}{k} and then performs an equivalent of copying and pasting to the console the code for the second plot, which in the ``rlc'' library can be done with just the \mintinline{R}{updateCharts} for the sake of simplicity. Basically, the core idea here is so identical to the usual spot checking routine that one can just give our imaginary \mintinline{R}{makePlot} function to the ``rlc'' chart (replacing lines 10-12 with \mintinline{R}{onClick = makePlot}) and it will stil work. One only should be aware that in this case the argumet to the \mintinline{R}{makePlot} will be an index of the selected gene and not its name.

Thus, there are simply no additional requirements to the data or environment, no practices that one should adopt, in order to perform the usual exploratory analysis or even to convert an existing script into an interactive app. Figure \ref{FigE} shows such a transformation in details for another example of a common spot check practice.


\begin{figure*}[h]
  \includegraphics[width=\textwidth]{FigE/figE.png}
  \caption{Examples of simple plots that are commonly used during exploratory analisys with the code to produce them. Basic plots of ``rlc'' (c, d) package are not more complicated than their static alternatives (a, b), which makes R/LinkedCharts suitable for every day on-the-fly analisys. For static heatmap (a), the ``pheatmap'' package was used; scatter plot (b) was made with a base R function. The heatmaps (a, c) show Spearman correlation of gene expression for all samples from \citet{conway_2015}. To the right from the heatmaps there is gene expression from the two samples (normal and dysplasia tissues from the same patient) plotted against each other (b, d). Normal tissue sample (along x-axis) is one of the outliers that can be seen on any of the heatmaps (the samples that have lower then average correlation in the dataset with all other samples). Here, we consider such simple scatter plots as the quickest way of trying to see what is different about some of the samples. For the sake of simplicity, gene expression for all the samples is subsetted to 8000 randomly selected genes.}
  \label{FigE}
\end{figure*}

Start from need for spot check, add clustering to RCL, change default colour scale,


For example, let's again look at the oral cancer data \citep{conway_2015}. There are overall 57 samples, three from each patient. Previously, we've looked at differentially expressed genes between normal and cancerous tissues. Still, before getting there, a researcher who has just obtained these data may want to get some samples overview. One of the common ways to do so is to check how well the samples correlate with each other by making a correlation heatmap. Assume that we store the sample correlation matrix in the \mintinline{R}{corMat} variable. Figure \ref{FigE} shows a static heatmap from a popular ``pheatmap'' \citep{kolde_2019} package (a) and an interactive heatmap from  the ``rlc'' package (c). Below each heatmap a command to generate it is shown. Both commands look similarly simple, and the only big difference is INTERACTIVITY! in the output is that the rows and columns of the static heatmap (a) are clustered. However, hierarchical clustering is also implemented in R/LinkedCharts heatmaps but is off by default, unlike in ``pheatmap''. One can switch it on with the same arguments \mintinline{R}{clusterRows} and \mintinline{R}{clusterCols} as in ``pheatmap''.

From any of the heatmaps we can see, that some of the samples are very much different from all others. The next thing one can ask is what is wrong with them. For the first and quick \emph{ad hoc} check one may decide to plot gene expression in several samples against each other to see if any noticeable patterns will hint a direction for further analysis. Let's say, that by looking at the heatmap, we've decided to start with plotting samples ``PG123-N'' and ``PG123-D''. These are normal and dysplasia samples from the same patients respectively and the normal one is one of the noticeable outliers.

\begin{minted}{R}
xSample <- "PG123-N"
ySample <- "PG123-D"
\end{minted}

Simple scatter plots from base R and ``rlc'' to compare normalized gene expression for both of the samples are shown in Figure \ref{FigE} (b, d) together with the code to produce them. Once again, both code lines are simple enough to be used for some quick on-the-fly checks.

This comparison alone doesn't tell us much, unless we look plot more samples against each other to see how expression for other samples look like, what is "high correlation" for this dataset and what is "low correlation". To this end we will have to store some other sample IDs to \mintinline{R}{xSample} and \mintinline{R}{ySample} variables and rerun the code to generate scatter plots again. Here comes the first point, where interactivity can facilitate exploration. If you surround \mintinline{R}{x} and \mintinline{R}{y} arguments of \mintinline{R}{lc_scatter} with the \mintinline{R}{dat} function, you can update the scatter with a call to the \mintinline{R}{updateCharts} function instead of rerunning the code. The full code will look like this:

\begin{minted}{R}
xSample <- "PG123-N"
ySample <- "PG123-D"

lc_scatter(dat(x = normCounts[, xSample], 
   y = normCounts[, ySample]),
   size = 1.5)

xSample <- "PG123-T"
updateCharts()
\end{minted}

If one is going to check multiple pairs of samples, it's only natural to put the last two lines in a function, that takes two samples and plots them agains each other.

\begin{minted}{R}
changePlots <- function(x, y) {
  xSample <- x
  ySample <- y
  updateCharts()
}
\end{minted}

At this point, we still need to decide what samples to plot and manually type in their names or indices. This can be avoided simply by supplying this function to the heatmap. Now, instead of entering sample names one can just click on a heatmap cell and it's row and column indices will be automatically given to the function and the scatter plot will be updated. As a result, we've made a functional interactive app with only the step that one may anyway perform during a routine exploratory analisys. The resulting code is shown below. You can also find a little bit prettified live version in the supplement and use it to see that the outlier samples are the ones that were sequenced less deep.

\begin{minted}{R}
lc_heatmap(value = corMat,
   on_click = function(d) {
      xSample <<- d[1]
      ySample <<- d[2]
      updateCharts()
   })
lc_scatter(dat(x = normCounts[, xSample], 
   y = normCounts[, ySample]),
   size = 1.5)
\end{minted}

\subsubsection{Server apps}

Any R/LinkedCharts app starts a server that listens to a given or randomly chosen port. A request from any browser for a starting page to this server will be answered with all the charts user has added so far. In practice it means that any R/LinkedCharts app can be accessed by multiple users, if they can make request to the server, and this doesn't require any additional parameters to be set. Any of the examples, we've shown in different sections of this paper can become apps that are deployed on a server.

For the complete functionality, there is just one thing that is needed to taken care of. If you once again take a look at the code for previously mentioned examples, you can notice that there is usually one or several ``state'' variables. These are gerenally global variables that store currently selected genes, samples, etc. and are changed inside callback functions: \mintinline{R}{gene} from the example in section "Linking charts", \mintinline{R}{xSample} and \mintinline{R}{ySample} from the example in the previous section. Now, if several users are accessing these apps simultaneously, each click will change the state variables and therefore changing charts for all the users. This still may be usefull if, for example, several people are using the app as a visual addition to an online meeting. Yet in most cases one would like interactivity to be independent for each user.

To this end, one need just to specify the state variables within the \mintinline{R}{openPage} function and give them some default values. For instance, example from the previous section can be turned into a server app simply by adding the following line in the beginning.

\begin{minted}{R}
openPage(sessionVars = list(xSample = 1, ySample = 2))
\end{minted}

Now, multiple users can work with an individual state of the app.

Of course, there are other things that can make a server app more customized. One can add some default content to each opened page (in addition to all the charts that are added by default), control each client session (and, for example, close those, that don't show any activity for considerable amount of time), limit memory usage or number of active connections simultaneously. Yet, all these parameters are optional. More information about possible options can be found on R man pages for classes \mintinline{R}{App} and \mintinline{R}{Session} of our ``jrc'' package.

\subsubsection{Stand-alone apps}

\begin{figure*}[h]
  \includegraphics[width=\textwidth]{FigF/figF.png}
  \caption{An example of a stand-alone app with LinkedCharts. The app was used as a supplement for (reference)}
  \label{FigF}
\end{figure*}

Any app made with R/LinkedCharts (``rlc'' package) requires an R session that runs either locally or on the server. Yet, R session is only responsible for sending required data to the app, while all the visualization and interactivity handling happens on the JavaScript side. This fact makes it possible to use LinkedCharts for generating stand-alone apps in a form of an HTML page. Such a page can then be sent to a collaborator or used as a supplement file for a paper. Unlike a link to an app deployed somewhere on a server, this kind of interactive supplement will be awaylable to any user with an installed web-browser at any moment, without a need for the research team to maintain a runnig app on the server. A supplement to this paper is an example of such an app, contained within an HTML page. Another app was made for (referece to translation paper). A screenshot of this app is shown in Figure \ref{FigF}.

However, to make such an app one has to be familiar with JavaScript. We've tried to make the necessary level of experience with JavaScript as low as possible, but understanding of syntax and some basic concepts is still required. In the supplement to this paper you can also find JS code for all the apps. The data has to be preprocessed (alternatively, all the calculations may be implemented in JavaScript, but that can be complicated) and saved, for example, in JSON format. The result can be directly inserted into the JS code. There are also ohter ways of loading data into the linked-charts.js app, which are described in our tutorial https://anders-biostat.github.io/linked-charts/js/tutorials/data.html. Also on this web-page one can find more tutorials and examples for a JavaScript part of the LinkedCharts library.

\subsection{Further customization}

Since LinkedCharts is JavaScript based, it can be combined with many existing web solutions without changing source code of the package. One can cultomize how the charts look like with CSS, add additional scripts, specify an HTML layout. R/LinkedCharts can add interactive charts to an existing HTML page supplied as \mintinline{R}{startPage} argument of the \mintinline{R}{openPage}. Additional images, files or scripts can be loaded from a directory specified by the \mintinline{R}{rootDirectory} argument. And finally, the ``jrc'' package (available on CRAN) on top of which ``rlc'' is built allows you to run any JavaScript code directly from your R session.
All this gives you full control of how your app looks like and behaves and can be fitted to the specific needs of your current project.

\subsection{Implementation}

R/LinkedCharts is a JavaScript visualization library with R-based \citep{R_2019} interface. The JavaScipt part is build on top of D3 \citep{bostock_2011} and the user-interface is provided by the ``jrc'' package \citep{jrc_2020}, which in turn heavily relies on the ``httpuv'' \citep{cheng_2020} package.

\begin{small} 
\balance
\bibliography{lc}
\end{small}

\end{document}


