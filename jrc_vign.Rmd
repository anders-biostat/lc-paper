---
title: "jrc tutorial"
output: html_notebook
---

`jrc` is a lightweight and straightforward library to create a bridge between a web-page, opened in a browser and a running R session. It allows R session to react to user's interaction with the web page by storing some information for further use, while the web-session can utilize results of calculations performed by the R session and in interactive manner show them to the user.

The core idea of `jrc` is its straight-forwardness. It contains only the essential tools to fully control a web-page from an R session and vice versa. There are of course certain limitations for security reasons, but in general any peace of R or JavaScript code can be sent via a web socket connection, executed and results, if any, can be sent back and and evaluated on the other side of the connection. In this manner, one can utilize the best of the two worlds: R proved to be a great tool for statistical computations and JavaScript is aimed at visualization and interactivity. In addition to commands exchange `jrc` also provides instruments for maintaining multiple connections to a single R-session, which is useful for publicly available apps.

`jrc` is intended for R package developers as a tool to build interactive apps.

This vignette will lead you through a detailed example of making a `jrc` app. Some knowledge of both R and JavaScript is required. Here, we stick to vanilla JS, which cause some examples to be unnecessary lengthy, but we wanted to keep it as universal as possible. In practice, of course, one can utilize any of existing JS libraries.

## Exchanging commands

```{r}
library(jrc)
library(ggplot2)
```

So let's start with exploring the possibilities of a web socket connection (established with the `httpuv` package) in a simple toy example. To this end, we are going to use the iris dataset.

```{r}
data("iris")
```

`jrc` works by running a local server and uploading its JavaScript part to any served HTML page. In this way, when a web socket connection is established, the web page knows exactly, how to process incoming and outgoing messages. One may start an app by first initializing a new app, starting a server and then opening its start page in a browser or simply by running the `openPage` function. This function has numerous arguments that define the basic aspects of the app's behaviour. Most of them can be changed later, if needed. Some, such as port to which the local server will listen for requests, can't.

```{r}
openPage()
```

Now, in the RStudio viewer if available, or in a browser window otherwise, you should see an empty HTML page. `jrc` can run any custom code on this page or add HTML elements. Lets' add a title.

```{r}
sendHTML("<h2>My app</h2>")
```

The title should appear on the web page immediately after running the line above. And what about something more complicated, let say, images? Unfortunately, `jrc` doesn't support sending R plots directly to the web page, but there is an easy alternative. We can store a plot somewhere locally, and then add it to the web-page as an `img` tag.

```{r}
ggplot(iris) + geom_point(aes(Sepal.Length, Petal.Length, colour = Species))
```

This simple plot we are going to add to the page. We will store as a temporary file, using the `tempfile` to get name and path to the file

```{r}
fileName <- tempfile(fileext = ".png")

png(fileName, width = 500, height = 400)
ggplot(iris) + geom_point(aes(Sepal.Length, Petal.Length, colour = Species))
dev.off()

fileName
```

Now we just need to tell server, where to look for the image when someone requests it. General idea is that one just specifies path to the file, R session reads it and sends it to the web page. However, here two complications arise. The first one, is security. Unlike JavaScript code running in a browser, R can access almost any local file, which means that if a `jrc` app is made public, one may try to request for private local files by their paths. The second issue concerns full paths. If you're using Mac or Linux system, there is no problems with using absolute path as a part of a web address, but it's not true for Windows users.

There is a single solution to both issues. Each `jrc` app, has a list of `allowedDirectories` (check the corresponding argument of the `openPage` function). Only files from these directories can be served, and one should specify paths relative to one of them (they will be checked in order and the first found file will be served). There are two directories that are allowed by default. One is the `rootDirectory` that can be set via an argument of the `openPage` function, the other is the working directory of the R session at the moment, when app was initialized. Therefore to add our plot to the page, we first need to allow the app access to the temporary directory.

```{r}
allowDirectories(tempdir())
sendHTML(paste0("<img src='", basename(fileName), "' id='myImage'/>"))
```

Unfortunately, to change the image we can't just overwrite it with a new one. The old plot will remain cashed in the browser, and to display a new plot one should generate a new file name. 

```{r}
newFileName <- tempfile(fileext = ".png")
png(newFileName, width = 500, height = 400)
ggplot(iris) + geom_point(aes(Sepal.Width, Petal.Width, colour = Species))
dev.off()
```
Now we can change the `src` attribute of the existing image. To this end, we can use the `sendCommand` function of the `jrc` package. Unlike `sendHTML` function that just adds its input to the page, `sendCommand` executes custom JavaScript code.

```{r}
sendCommand(paste0("document.getElementById('myImage').src = '", basename(newFileName), "';"))
```

The two plots are different by the columns of the original dataset from which we took x and y values to plot. We can add to our toy app some interactivity by allowing user to choose which columns to plot against each other. We add two drop down lists, one for x and one for y axis.

```{r}
sendHTML(paste0("<p> x: <select onchange='updatePlot();' id='x_select'></select>", 
                "y: <select onchange='updatePlot();' id='y_select'></select></p>"))
```

Next step is to fill these two empty lists with options. Since there are just four columns in our example dataset besides `Species`, one could have easily typed them all in the previous step. Yet the aim of this tutorial is to familiarize reader with `jrc` interface and therefore, we'll try to avoid copy-pasting.

First, we tell the web page about our four columns with the `sendData` function. It creates on the web page a variable with the specified name and then stores there content of some R variable. Some type conversion is unavoidable. Unlike R JavaScript doesn't have special variable types for 2D arrays (matrices or data.frames), therefore matrices are converted in array of arrays (`rowwise` argument allows you to control it), data.frames turn into array of objects (`rowwise = TRUE`, default) or objects with an array for each column (`rowwise = FALSE`). At the same time JavaScript distinguishes atomic types from arrays, while R doesn't. `a <- 1` produces a vector of length one, but R user may not even notice that, since and JavaScript has now way of knowing, whether this is supposed to be just a number or an array. By default, any vector of length 1 is turned into an atomic type by the `sendData` function, but this can be avoided by setting `keepAsVector = TRUE`.

In our case, everything is quite simple: we just send a vector of column names and get an array of strings.

```{r}
sendData("options", colnames(iris)[1:4])
```

Now we want to have a function on the web page side, that can use this new variable to fill the drop down list. To define it, we will use `sendCommand` function. Then we will call it twice with the `callFunction` function.

```{r}
sendCommand(paste0(
  "addOptions = function(axis) {",
	  "options.map(function(name) {",
		  "opt = document.createElement('option');",
		  "opt.value = name;",
		  "opt.innerHTML = name;",
		  "document.getElementById(axis + '_select').appendChild(opt);",
	  "})",
  "}"
))

callFunction("addOptions", list("x"))
callFunction("addOptions", list("y"))
```

Finally, to make it all work we still need to define the `updatePlot` function, that will tell R session to generate a new plot and send back the new URL.

```{r}
sendCommand(paste0(
  "updatePlot = function() {",
	  "jrc.callFunction('updatePlot',",
		  "[document.getElementById('x_select').value, document.getElementById('y_select').value])",
  "}"
))
```

Note, the `jrc.callFunction` in the code above. All `jrc` R functions for sending data and commands to the web page, have their JavaScript counterparts. In general, they should be used in the same way and with the same arguments as the corresponding R functions, but there are still some minor differences. Description of each JavaScript `jrc` function one can find on the man page of the R function with the same name. `sendHTML` doesn't have a JavaScript counterpart.

So the only thing our JavaScript `updatePlot` function does is calling an R function with the same name and passing to it two arguments, which are currently selected column names for x and y axes. Let's define this function in the R session, combining previously explained code.

```{r}
updatePlot <- function(x, y) {
  fileName <- tempfile(fileext = ".png")
  png(fileName, width = 500, height = 400)
  print(ggplot(iris) + geom_point(aes(get(x), get(y), colour = Species)))
  dev.off()
  
  sendCommand(paste0("document.getElementById('myImage').src = '", basename(fileName), "';"))
}
```

The app now is mostly functional, but if one tries now to change the plot using the drop down lists, a message will appear to inform that this action must be authorized in the R session. At the same time a similar message appears in the R console. Someone with access to the R session needs to run the `authorize` function with the arguments from the message to allow the call of `updatePlot`. Since R session can read and write local files and use system functions, it is dangerous to provide a web page uncontrolled access to R's functionality. To this end any message, received via a web socket, can be processed only after it has been approved in the R session. Until then all incoming messages are stored in the memory and can be explored or deleted. One can limit size of the storage to prevent memory overuse.

Of course, for an interactive app, manual confirmation for every incoming action is very inconvenient. Therefore every `jrc` app has a list of `allowedFunctions` and `allowedVariables`. Allowed functions are the ones that can be called automatically, without manual authorization. Allowed variables can be overwritten from a web page side (it is still possible to set a maximal allowed size of variables). So in our example, we would like `updatePlot` to be called automatically, without asking for permission. We could have done it in the very beginning by setting the `allowedFunctions` argument of the `openPage` function or we can do it now using the `allowFunctions` function.

```{r}
allowFunctions("updatePlot")
```

Now our toy app is ready.

### Start page

You may have noticed, that to make the app above most of the stages were to put some JavaScript or HTML code to the web page. Instead of turning big chunks of code to character vectors and using them as input for `sendHTML` and `sendCommand` functions one may prefer to write a proper HTML page and use `jrc` functions only to ensure interactivity. That can be easily done with `jrc`. By default, `openPage` starts with empty HTML page, but it can use any custom page instead.

So, instead running all the code above, we could have saved an `app.html` file with all the static code and then use it as `startPage` argument of the `openPage` function

```
<h2>My app</h2>
<img src='#!' id='myImage'/>
<p>
	x: <select onchange='updatePlot();' id='x_select'></select> 
  y: <select onchange='updatePlot();' id='y_select'></select>
</p>
<script type="text/javascript">
  addOptions = function(axis) {
	  options.map(function(name) {
		  opt = document.createElement('option');
		  opt.value = name;
		  opt.innerHTML = name;
		  document.getElementById(axis + '_select').appendChild(opt);
	  })
  }
  updatePlot = function() {
	  jrc.callFunction('updatePlot',
		  [document.getElementById('x_select').value, document.getElementById('y_select').value])
  }
</script>
```

```{r}
openPage(startPage = "app.html", 
         allowedDirectories = tempdir(), 
         allowedFunctions = "updatePlot")
```

Now, same as previously, we need to fill the drop down lists with options, define `updatePlot` function in R and set the first plot.

```{r}
sendData("options", colnames(iris)[1:4])

callFunction("addOptions", list("x"))
callFunction("addOptions", list("y"))

updatePlot("Sepal.Length", "Sepal.Length")
```

### Multiuser app

So far our toy app was designed to be used locally. Let's see what changes, if we want it to work for several users simultaneously.

First of all, core of multiuser functionality is always present in a `jrc`. If now an app from the example above is running, one can open another page in any browser and get our `app.html` page with all the `jrc` functionality in there. To try this, you will need to know to which port the local server is listening (just use the `getPort` function for this). By default, a port is assigned randomly, using `httpuv::getPort()` function, but can also be set by the `port` argument of the `openPage` function. When you know the port number, you can open `localhost:'portNumber'` page in any browser. The app will automatically establish another web socket connection and ensure the full `jrc` functionality for this new page. However, the drop down lists on the new page will be empty. We've filled them with options manually, and this hasn't yet been done for the new connection. It's possible to do the same for the new page again by running the same code, but now with `sessionId` argument (see below for more information), but that wouldn't work if we want users to be able to open and close our app whenever they want. To this end, there is an `onStart` argument of the `openPage` function. This argument takes in a callback function, which it used to fill each new page with some default content. To make it work, one needs a bit more understanding about the inner structure of a `jrc` app.

Let's first see how the `openPage` command for our multiuser app should look like.

```{r}
openPage(startPage = "app.html", 
         allowedDirectories = tempdir(), 
         allowedFunctions = "updatePlot",
         onStart = function(session) {
            session$sendData("options", colnames(iris)[1:4])
            session$callFunction("addOptions", list("x"))
            session$callFunction("addOptions", list("y"))
            
            session$sendCommand("jrc.callFunction('updatePlot', ['Sepal.Length', 'Sepal.Length']);")
         })
```

The `updatePlot` function also needs to be slightly changed.

```{r}
updatePlot <- function(x, y) {
  fileName <- tempfile(fileext = ".png")
  png(fileName, width = 500, height = 400)
  print(ggplot(iris) + geom_point(aes(get(x), get(y), colour = Species)))
  dev.off()
  
  sendCommand(paste0("document.getElementById('myImage').src = '", basename(fileName), "';"),
              sessionId = .sessionId)
}
```

And now let's go through the changes. In short, they are all about letting the app know what web page to update. We didn't need it previously, since there was always just one opened page. Note, that there are multiple ways to do that. Here, only one of the possibilities is shown.

Any app is an instance of class `App`. When you call the `openPage` function, a new instance is initialized and stored in package's namespace. It is also returned by the `openPage` function or can be later retrieved with `getPage` function. Whenever a new web socket connection is established a new object of class `Session` is created and stored inside the `App` object. Any function that controls general behaviour of the app is a method of class `App`, a function that works with a specific web page is a method of class `Session`. The functions that we've used so far are all wrappers around corresponding methods: they take the `App` object that is currently stored by the package, get the required session, if necessary, and call the corresponding method.

The `onStart` function gets an object of class `Session` as its argument, and now, instead of using wrapper functions as before, we call methods of this object to make sure that the default content is added only to the new session and not to those, that already exist. Another change concerns the `updatePlot` function. Instead of calling it directly, we now make the web page to request the update. This is done, so the the `updatePlot` could also get information on what session requires the update. Here, in the `updatePlot` function, we are not using the `Session` object. Instead, we specify the session by its ID, which each new session gets upon its initialization. You can check IDs for all the currently running sessions with the `getSessionIds` function.

Every `Session` object has it's own environment to store user-specific variables, which can be accessed by any function called by `jrc.callFunction`. Generally, these variables should be defined with the `setSessionVariables` function or `sessionVariables` argument of the `openPage` function. However, by default a `.sessionId` variable is added to the environment of any new session, so that a function can get information about it's session. In the example above, we use this variable to update only one opened plot. Note, that now `updatePlot` will throw an error if one tries to call it from the R session directly and not from the web page.

### Cleaning up

So far to update a plot, we kept saving a new one in the temporary directory, while keeping all the old ones. That's fine for a local app. Temporary directory with all the plots will be removed after one closes the R session and it's very unlikely, that one user will make too many plots to create a memory problem. However, it changes, when our toy app becomes public. A server app usually runs for weeks and months without a restart, and all this time the plots will keep accumulating for every user who ever opened the web page. Of course, in this particular example, it still will take lot of calls to the `updatePlot` to create a real problem, since the stored images are quite small, but let's anyway make our app less memory consuming, since it can demonstrate other useful aspects of a `jrc` app.

This will require every session to know the file name for currently displayed image and also some cleaning up after the web socket connection is closed (the user closed the web page).

Let's start with storing image's URL. 

In the previous section we've mentioned a session environment. That's a perfect place to store and update any information that relates to this particular connection. There we will create a variable `currentImage` to store path to the currently displayed plot. It's also can be done inside the `openPage` function.

```{r}
openPage(startPage = "app.html", 
         allowedDirectories = tempdir(), 
         allowedFunctions = "updatePlot",
         sessionVars = list(currentImage = ""),
         onStart = function(session) {
            session$sendData("options", colnames(iris)[1:4])
            session$callFunction("addOptions", list("x"))
            session$callFunction("addOptions", list("y"))
            
            session$sendCommand("jrc.callFunction('updatePlot', ['Sepal.Length', 'Sepal.Length']);")
         })
```

As you can see, right now the `currentImage` variable contains an empty string, but we still need to declare it for the app to know, that if a session attempts to change this variable, it should do so inside it's own environment and not in the global one. Now `updatePlot` can read this variable to remove an old plot and store instead the path to the new one.

```{r}
updatePlot <- function(x, y) {
  if(file.exists(currentImage))
    file.remove(currentImage)
  
  currentImage <<- tempfile(fileext = ".png")
  png(currentImage, width = 500, height = 400)
  print(ggplot(iris) + geom_point(aes(get(x), get(y), colour = Species)))
  dev.off()
  
  sendCommand(paste0("document.getElementById('myImage').src = '", basename(currentImage), "';"),
              sessionId = .sessionId)
}
```

We can use session variables inside the `updatePlot` the same way as any other variable, but to change them `<<-` operator is required, since the variable exists outside the function. `jrc` will automatically use the variable from the session that called the `updatePlot` function. Same variable for other sessions will remain intact.

Now we store only one image per session, but the last one still remains even after user closes the web page. To remove it, we can use the `onClose` argument of the `openPage` function. It is very similar to the `onStart` callback, but is called when the web socket connection is closed. Here, we explicitly get the variable from the environment of the given session.

```{r}
openPage(startPage = "app.html", 
         allowedDirectories = tempdir(), 
         allowedFunctions = "updatePlot",
         sessionVars = list(currentImage = ""),
         onStart = function(session) {
            session$sendData("options", colnames(iris)[1:4])
            session$callFunction("addOptions", list("x"))
            session$callFunction("addOptions", list("y"))
            
            session$sendCommand("jrc.callFunction('updatePlot', ['Sepal.Length', 'Sepal.Length']);")
         },
         onClose = function(session) {
           currentImage <- session$sessionVariables("currentImage")
           if(file.exists(currentImage))
              file.remove(currentImage)
         })
```
